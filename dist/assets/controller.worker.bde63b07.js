(function(){"use strict";class Gt{constructor(e=[],n=Qt){if(this.data=e,this.length=this.data.length,this.compare=n,this.length>0)for(let t=(this.length>>1)-1;t>=0;t--)this._down(t)}push(e){this.data.push(e),this.length++,this._up(this.length-1)}pop(){if(this.length===0)return;const e=this.data[0],n=this.data.pop();return this.length--,this.length>0&&(this.data[0]=n,this._down(0)),e}peek(){return this.data[0]}_up(e){const{data:n,compare:t}=this,s=n[e];for(;e>0;){const r=e-1>>1,i=n[r];if(t(s,i)>=0)break;n[e]=i,e=r}n[e]=s}_down(e){const{data:n,compare:t}=this,s=this.length>>1,r=n[e];for(;e<s;){let i=(e<<1)+1,h=n[i];const l=i+1;if(l<this.length&&t(n[l],h)<0&&(i=l,h=n[l]),t(h,r)>=0)break;n[e]=h,e=i}n[e]=r}}function Qt(o,e){return o<e?-1:o>e?1:0}const yt=o=>{const{v1:e,v2:n}=o;let t=0;for(let s=0;s<e.length;s++){let r=(e[s]^n[s])>>>0;t+=Wt(r)}return t},Wt=o=>{var e=o-(o>>1&1431655765);return e=(e>>2&858993459)+(e&858993459),e=(e>>4)+e&252645135,e=(e>>8)+e&16711935,e=(e>>16)+e&65535,e},ut=1,Nt=o=>{const{keywidth:e,keyheight:n,querywidth:t,queryheight:s,matches:r}=o,i=t*1.2,h=-i,l=s*1.2,u=-l,f=12,g=10,a=-1,j=1,y=1/Math.log(10),m=Math.max(e,n),M=Math.floor(e/2),z=Math.floor(n/2),E=[];for(let v=0;v<r.length;v++){const V=r[v].querypoint.scale,J=r[v].keypoint.scale;J==0&&console.log("ERROR divide zero");const N=V/J;E.push(N*m)}E.sort((v,V)=>v-V);const R=.25*E[Math.floor(E.length/2)-(E.length%2==0?1:0)-1],q=Math.max(5,Math.ceil((i-h)/R)),b=Math.max(5,Math.ceil((l-u)/R)),F=q*b,X=F*f,c=[],w=[],S={};for(let v=0;v<r.length;v++){const V=r[v].querypoint,J=r[v].keypoint,{x:N,y:B,scale:L,angle:C}=Zt({querypoint:V,keypoint:J,keycenterX:M,keycenterY:z,scaleOneOverLogK:y});if(N<h||N>=i||B<u||B>=l||C<=-Math.PI||C>Math.PI||L<a||L>=j){c[v]=!1;continue}let U=q*(N-h)/(i-h),wt=b*(B-u)/(l-u),pt=f*(C+Math.PI)/(2*Math.PI),dt=g*(L-a)/(j-a);w[v]={binX:U,binY:wt,binAngle:pt,binScale:dt};let rt=Math.floor(U-.5),it=Math.floor(wt-.5),lt=Math.floor(dt-.5),jt=(Math.floor(pt-.5)+f)%f;if(rt<0||rt+1>=q||it<0||it+1>=b||lt<0||lt+1>=g){c[v]=!1;continue}for(let ht=0;ht<2;ht++){let kt=rt+ht;for(let bt=0;bt<2;bt++){let hn=it+bt;for(let It=0;It<2;It++){let un=(jt+It)%f;for(let Rt=0;Rt<2;Rt++){let cn=lt+Rt;const vt=kt+hn*q+un*F+cn*X;S[vt]===void 0&&(S[vt]=0),S[vt]+=1}}}}c[v]=!0}let d=0,P=-1;if(Object.keys(S).forEach(v=>{S[v]>d&&(d=S[v],P=v)}),d<3)return[];const O=Math.floor(P%X%F%q),T=Math.floor((P-O)%X%F/q),D=Math.floor((P-O-T*q)%X/F),Y=Math.floor((P-O-T*q-D*F)/X),G=[];for(let v=0;v<r.length;v++){if(!c[v])continue;const V=w[v];if(Math.abs(V.binX-(O+.5))>=ut||Math.abs(V.binY-(T+.5))>=ut||Math.abs(V.binScale-(Y+.5))>=ut)continue;const L=Math.abs(V.binAngle-(D+.5));Math.min(L,f-L)>=ut||G.push(r[v])}return G},Zt=({querypoint:o,keypoint:e,keycenterX:n,keycenterY:t,scaleOneOverLogK:s})=>{let r=o.angle-e.angle;r<=-Math.PI?r+=2*Math.PI:r>Math.PI&&(r-=2*Math.PI);const i=o.scale/e.scale,h=i*Math.cos(r),l=i*Math.sin(r),u=[h,-l,l,h],f=[u[0]*e.x+u[1]*e.y,u[2]*e.x+u[3]*e.y],g=o.x-f[0],a=o.y-f[1];return{x:u[0]*n+u[1]*t+g,y:u[2]*n+u[3]*t+a,angle:r,scale:Math.log(i)*s}},xt=Object.prototype.toString;function ct(o){return xt.call(o).endsWith("Array]")}function At(o){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!ct(o))throw new TypeError("input must be an array");if(o.length===0)throw new TypeError("input must not be empty");var n=e.fromIndex,t=n===void 0?0:n,s=e.toIndex,r=s===void 0?o.length:s;if(t<0||t>=o.length||!Number.isInteger(t))throw new Error("fromIndex must be a positive integer smaller than length");if(r<=t||r>o.length||!Number.isInteger(r))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var i=o[t],h=t+1;h<r;h++)o[h]>i&&(i=o[h]);return i}function te(o){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!ct(o))throw new TypeError("input must be an array");if(o.length===0)throw new TypeError("input must not be empty");var n=e.fromIndex,t=n===void 0?0:n,s=e.toIndex,r=s===void 0?o.length:s;if(t<0||t>=o.length||!Number.isInteger(t))throw new Error("fromIndex must be a positive integer smaller than length");if(r<=t||r>o.length||!Number.isInteger(r))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var i=o[t],h=t+1;h<r;h++)o[h]<i&&(i=o[h]);return i}function qt(o){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(ct(o)){if(o.length===0)throw new TypeError("input must not be empty")}else throw new TypeError("input must be an array");var n;if(e.output!==void 0){if(!ct(e.output))throw new TypeError("output option must be an array if specified");n=e.output}else n=new Array(o.length);var t=te(o),s=At(o);if(t===s)throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");var r=e.min,i=r===void 0?e.autoMinMax?t:0:r,h=e.max,l=h===void 0?e.autoMinMax?s:1:h;if(i>=l)throw new RangeError("min option must be smaller than max option");for(var u=(l-i)/(s-t),f=0;f<o.length;f++)n[f]=(o[f]-t)*u+i;return n}const ft=" ".repeat(2),_t=" ".repeat(4);function ee(){return zt(this)}function zt(o,e={}){const{maxRows:n=15,maxColumns:t=10,maxNumSize:s=8}=e;return`${o.constructor.name} {
${ft}[
${_t}${ne(o,n,t,s)}
${ft}]
${ft}rows: ${o.rows}
${ft}columns: ${o.columns}
}`}function ne(o,e,n,t){const{rows:s,columns:r}=o,i=Math.min(s,e),h=Math.min(r,n),l=[];for(let u=0;u<i;u++){let f=[];for(let g=0;g<h;g++)f.push(se(o.get(u,g),t));l.push(`${f.join(" ")}`)}return h!==r&&(l[l.length-1]+=` ... ${r-n} more columns`),i!==s&&l.push(`... ${s-e} more rows`),l.join(`
${_t}`)}function se(o,e){const n=String(o);if(n.length<=e)return n.padEnd(e," ");const t=o.toPrecision(e-2);if(t.length<=e)return t;const s=o.toExponential(e-2),r=s.indexOf("e"),i=s.slice(r);return s.slice(0,e-i.length)+i}function oe(o,e){o.prototype.add=function(t){return typeof t=="number"?this.addS(t):this.addM(t)},o.prototype.addS=function(t){for(let s=0;s<this.rows;s++)for(let r=0;r<this.columns;r++)this.set(s,r,this.get(s,r)+t);return this},o.prototype.addM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let r=0;r<this.columns;r++)this.set(s,r,this.get(s,r)+t.get(s,r));return this},o.add=function(t,s){return new e(t).add(s)},o.prototype.sub=function(t){return typeof t=="number"?this.subS(t):this.subM(t)},o.prototype.subS=function(t){for(let s=0;s<this.rows;s++)for(let r=0;r<this.columns;r++)this.set(s,r,this.get(s,r)-t);return this},o.prototype.subM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let r=0;r<this.columns;r++)this.set(s,r,this.get(s,r)-t.get(s,r));return this},o.sub=function(t,s){return new e(t).sub(s)},o.prototype.subtract=o.prototype.sub,o.prototype.subtractS=o.prototype.subS,o.prototype.subtractM=o.prototype.subM,o.subtract=o.sub,o.prototype.mul=function(t){return typeof t=="number"?this.mulS(t):this.mulM(t)},o.prototype.mulS=function(t){for(let s=0;s<this.rows;s++)for(let r=0;r<this.columns;r++)this.set(s,r,this.get(s,r)*t);return this},o.prototype.mulM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let r=0;r<this.columns;r++)this.set(s,r,this.get(s,r)*t.get(s,r));return this},o.mul=function(t,s){return new e(t).mul(s)},o.prototype.multiply=o.prototype.mul,o.prototype.multiplyS=o.prototype.mulS,o.prototype.multiplyM=o.prototype.mulM,o.multiply=o.mul,o.prototype.div=function(t){return typeof t=="number"?this.divS(t):this.divM(t)},o.prototype.divS=function(t){for(let s=0;s<this.rows;s++)for(let r=0;r<this.columns;r++)this.set(s,r,this.get(s,r)/t);return this},o.prototype.divM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let r=0;r<this.columns;r++)this.set(s,r,this.get(s,r)/t.get(s,r));return this},o.div=function(t,s){return new e(t).div(s)},o.prototype.divide=o.prototype.div,o.prototype.divideS=o.prototype.divS,o.prototype.divideM=o.prototype.divM,o.divide=o.div,o.prototype.mod=function(t){return typeof t=="number"?this.modS(t):this.modM(t)},o.prototype.modS=function(t){for(let s=0;s<this.rows;s++)for(let r=0;r<this.columns;r++)this.set(s,r,this.get(s,r)%t);return this},o.prototype.modM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let r=0;r<this.columns;r++)this.set(s,r,this.get(s,r)%t.get(s,r));return this},o.mod=function(t,s){return new e(t).mod(s)},o.prototype.modulus=o.prototype.mod,o.prototype.modulusS=o.prototype.modS,o.prototype.modulusM=o.prototype.modM,o.modulus=o.mod,o.prototype.and=function(t){return typeof t=="number"?this.andS(t):this.andM(t)},o.prototype.andS=function(t){for(let s=0;s<this.rows;s++)for(let r=0;r<this.columns;r++)this.set(s,r,this.get(s,r)&t);return this},o.prototype.andM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let r=0;r<this.columns;r++)this.set(s,r,this.get(s,r)&t.get(s,r));return this},o.and=function(t,s){return new e(t).and(s)},o.prototype.or=function(t){return typeof t=="number"?this.orS(t):this.orM(t)},o.prototype.orS=function(t){for(let s=0;s<this.rows;s++)for(let r=0;r<this.columns;r++)this.set(s,r,this.get(s,r)|t);return this},o.prototype.orM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let r=0;r<this.columns;r++)this.set(s,r,this.get(s,r)|t.get(s,r));return this},o.or=function(t,s){return new e(t).or(s)},o.prototype.xor=function(t){return typeof t=="number"?this.xorS(t):this.xorM(t)},o.prototype.xorS=function(t){for(let s=0;s<this.rows;s++)for(let r=0;r<this.columns;r++)this.set(s,r,this.get(s,r)^t);return this},o.prototype.xorM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let r=0;r<this.columns;r++)this.set(s,r,this.get(s,r)^t.get(s,r));return this},o.xor=function(t,s){return new e(t).xor(s)},o.prototype.leftShift=function(t){return typeof t=="number"?this.leftShiftS(t):this.leftShiftM(t)},o.prototype.leftShiftS=function(t){for(let s=0;s<this.rows;s++)for(let r=0;r<this.columns;r++)this.set(s,r,this.get(s,r)<<t);return this},o.prototype.leftShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let r=0;r<this.columns;r++)this.set(s,r,this.get(s,r)<<t.get(s,r));return this},o.leftShift=function(t,s){return new e(t).leftShift(s)},o.prototype.signPropagatingRightShift=function(t){return typeof t=="number"?this.signPropagatingRightShiftS(t):this.signPropagatingRightShiftM(t)},o.prototype.signPropagatingRightShiftS=function(t){for(let s=0;s<this.rows;s++)for(let r=0;r<this.columns;r++)this.set(s,r,this.get(s,r)>>t);return this},o.prototype.signPropagatingRightShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let r=0;r<this.columns;r++)this.set(s,r,this.get(s,r)>>t.get(s,r));return this},o.signPropagatingRightShift=function(t,s){return new e(t).signPropagatingRightShift(s)},o.prototype.rightShift=function(t){return typeof t=="number"?this.rightShiftS(t):this.rightShiftM(t)},o.prototype.rightShiftS=function(t){for(let s=0;s<this.rows;s++)for(let r=0;r<this.columns;r++)this.set(s,r,this.get(s,r)>>>t);return this},o.prototype.rightShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let r=0;r<this.columns;r++)this.set(s,r,this.get(s,r)>>>t.get(s,r));return this},o.rightShift=function(t,s){return new e(t).rightShift(s)},o.prototype.zeroFillRightShift=o.prototype.rightShift,o.prototype.zeroFillRightShiftS=o.prototype.rightShiftS,o.prototype.zeroFillRightShiftM=o.prototype.rightShiftM,o.zeroFillRightShift=o.rightShift,o.prototype.not=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,~this.get(t,s));return this},o.not=function(t){return new e(t).not()},o.prototype.abs=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.abs(this.get(t,s)));return this},o.abs=function(t){return new e(t).abs()},o.prototype.acos=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.acos(this.get(t,s)));return this},o.acos=function(t){return new e(t).acos()},o.prototype.acosh=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.acosh(this.get(t,s)));return this},o.acosh=function(t){return new e(t).acosh()},o.prototype.asin=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.asin(this.get(t,s)));return this},o.asin=function(t){return new e(t).asin()},o.prototype.asinh=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.asinh(this.get(t,s)));return this},o.asinh=function(t){return new e(t).asinh()},o.prototype.atan=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.atan(this.get(t,s)));return this},o.atan=function(t){return new e(t).atan()},o.prototype.atanh=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.atanh(this.get(t,s)));return this},o.atanh=function(t){return new e(t).atanh()},o.prototype.cbrt=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.cbrt(this.get(t,s)));return this},o.cbrt=function(t){return new e(t).cbrt()},o.prototype.ceil=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.ceil(this.get(t,s)));return this},o.ceil=function(t){return new e(t).ceil()},o.prototype.clz32=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.clz32(this.get(t,s)));return this},o.clz32=function(t){return new e(t).clz32()},o.prototype.cos=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.cos(this.get(t,s)));return this},o.cos=function(t){return new e(t).cos()},o.prototype.cosh=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.cosh(this.get(t,s)));return this},o.cosh=function(t){return new e(t).cosh()},o.prototype.exp=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.exp(this.get(t,s)));return this},o.exp=function(t){return new e(t).exp()},o.prototype.expm1=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.expm1(this.get(t,s)));return this},o.expm1=function(t){return new e(t).expm1()},o.prototype.floor=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.floor(this.get(t,s)));return this},o.floor=function(t){return new e(t).floor()},o.prototype.fround=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.fround(this.get(t,s)));return this},o.fround=function(t){return new e(t).fround()},o.prototype.log=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.log(this.get(t,s)));return this},o.log=function(t){return new e(t).log()},o.prototype.log1p=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.log1p(this.get(t,s)));return this},o.log1p=function(t){return new e(t).log1p()},o.prototype.log10=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.log10(this.get(t,s)));return this},o.log10=function(t){return new e(t).log10()},o.prototype.log2=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.log2(this.get(t,s)));return this},o.log2=function(t){return new e(t).log2()},o.prototype.round=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.round(this.get(t,s)));return this},o.round=function(t){return new e(t).round()},o.prototype.sign=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.sign(this.get(t,s)));return this},o.sign=function(t){return new e(t).sign()},o.prototype.sin=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.sin(this.get(t,s)));return this},o.sin=function(t){return new e(t).sin()},o.prototype.sinh=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.sinh(this.get(t,s)));return this},o.sinh=function(t){return new e(t).sinh()},o.prototype.sqrt=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.sqrt(this.get(t,s)));return this},o.sqrt=function(t){return new e(t).sqrt()},o.prototype.tan=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.tan(this.get(t,s)));return this},o.tan=function(t){return new e(t).tan()},o.prototype.tanh=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.tanh(this.get(t,s)));return this},o.tanh=function(t){return new e(t).tanh()},o.prototype.trunc=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.trunc(this.get(t,s)));return this},o.trunc=function(t){return new e(t).trunc()},o.pow=function(t,s){return new e(t).pow(s)},o.prototype.pow=function(t){return typeof t=="number"?this.powS(t):this.powM(t)},o.prototype.powS=function(t){for(let s=0;s<this.rows;s++)for(let r=0;r<this.columns;r++)this.set(s,r,Math.pow(this.get(s,r),t));return this},o.prototype.powM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let r=0;r<this.columns;r++)this.set(s,r,Math.pow(this.get(s,r),t.get(s,r)));return this}}function Q(o,e,n){let t=n?o.rows:o.rows-1;if(e<0||e>t)throw new RangeError("Row index out of range")}function W(o,e,n){let t=n?o.columns:o.columns-1;if(e<0||e>t)throw new RangeError("Column index out of range")}function A(o,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==o.columns)throw new RangeError("vector size must be the same as the number of columns");return e}function tt(o,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==o.rows)throw new RangeError("vector size must be the same as the number of rows");return e}function re(o,e,n){return{row:ie(o,e),column:le(o,n)}}function ie(o,e){if(typeof e!="object")throw new TypeError("unexpected type for row indices");if(e.some(t=>t<0||t>=o.rows))throw new RangeError("row indices are out of range");return Array.isArray(e)||(e=Array.from(e)),e}function le(o,e){if(typeof e!="object")throw new TypeError("unexpected type for column indices");if(e.some(t=>t<0||t>=o.columns))throw new RangeError("column indices are out of range");return Array.isArray(e)||(e=Array.from(e)),e}function Ft(o,e,n,t,s){if(arguments.length!==5)throw new RangeError("expected 4 arguments");if(at("startRow",e),at("endRow",n),at("startColumn",t),at("endColumn",s),e>n||t>s||e<0||e>=o.rows||n<0||n>=o.rows||t<0||t>=o.columns||s<0||s>=o.columns)throw new RangeError("Submatrix indices are out of range")}function gt(o,e=0){let n=[];for(let t=0;t<o;t++)n.push(e);return n}function at(o,e){if(typeof e!="number")throw new TypeError(`${o} must be a number`)}function et(o){if(o.isEmpty())throw new Error("Empty matrix has no elements to index")}function he(o){let e=gt(o.rows);for(let n=0;n<o.rows;++n)for(let t=0;t<o.columns;++t)e[n]+=o.get(n,t);return e}function ue(o){let e=gt(o.columns);for(let n=0;n<o.rows;++n)for(let t=0;t<o.columns;++t)e[t]+=o.get(n,t);return e}function ce(o){let e=0;for(let n=0;n<o.rows;n++)for(let t=0;t<o.columns;t++)e+=o.get(n,t);return e}function fe(o){let e=gt(o.rows,1);for(let n=0;n<o.rows;++n)for(let t=0;t<o.columns;++t)e[n]*=o.get(n,t);return e}function ge(o){let e=gt(o.columns,1);for(let n=0;n<o.rows;++n)for(let t=0;t<o.columns;++t)e[t]*=o.get(n,t);return e}function ae(o){let e=1;for(let n=0;n<o.rows;n++)for(let t=0;t<o.columns;t++)e*=o.get(n,t);return e}function me(o,e,n){const t=o.rows,s=o.columns,r=[];for(let i=0;i<t;i++){let h=0,l=0,u=0;for(let f=0;f<s;f++)u=o.get(i,f)-n[i],h+=u,l+=u*u;e?r.push((l-h*h/s)/(s-1)):r.push((l-h*h/s)/s)}return r}function we(o,e,n){const t=o.rows,s=o.columns,r=[];for(let i=0;i<s;i++){let h=0,l=0,u=0;for(let f=0;f<t;f++)u=o.get(f,i)-n[i],h+=u,l+=u*u;e?r.push((l-h*h/t)/(t-1)):r.push((l-h*h/t)/t)}return r}function pe(o,e,n){const t=o.rows,s=o.columns,r=t*s;let i=0,h=0,l=0;for(let u=0;u<t;u++)for(let f=0;f<s;f++)l=o.get(u,f)-n,i+=l,h+=l*l;return e?(h-i*i/r)/(r-1):(h-i*i/r)/r}function de(o,e){for(let n=0;n<o.rows;n++)for(let t=0;t<o.columns;t++)o.set(n,t,o.get(n,t)-e[n])}function ye(o,e){for(let n=0;n<o.rows;n++)for(let t=0;t<o.columns;t++)o.set(n,t,o.get(n,t)-e[t])}function Me(o,e){for(let n=0;n<o.rows;n++)for(let t=0;t<o.columns;t++)o.set(n,t,o.get(n,t)-e)}function Ee(o){const e=[];for(let n=0;n<o.rows;n++){let t=0;for(let s=0;s<o.columns;s++)t+=Math.pow(o.get(n,s),2)/(o.columns-1);e.push(Math.sqrt(t))}return e}function Se(o,e){for(let n=0;n<o.rows;n++)for(let t=0;t<o.columns;t++)o.set(n,t,o.get(n,t)/e[n])}function je(o){const e=[];for(let n=0;n<o.columns;n++){let t=0;for(let s=0;s<o.rows;s++)t+=Math.pow(o.get(s,n),2)/(o.rows-1);e.push(Math.sqrt(t))}return e}function ke(o,e){for(let n=0;n<o.rows;n++)for(let t=0;t<o.columns;t++)o.set(n,t,o.get(n,t)/e[t])}function be(o){const e=o.size-1;let n=0;for(let t=0;t<o.columns;t++)for(let s=0;s<o.rows;s++)n+=Math.pow(o.get(s,t),2)/e;return Math.sqrt(n)}function Ie(o,e){for(let n=0;n<o.rows;n++)for(let t=0;t<o.columns;t++)o.set(n,t,o.get(n,t)/e)}class _{static from1DArray(e,n,t){if(e*n!==t.length)throw new RangeError("data length does not match given dimensions");let r=new I(e,n);for(let i=0;i<e;i++)for(let h=0;h<n;h++)r.set(i,h,t[i*n+h]);return r}static rowVector(e){let n=new I(1,e.length);for(let t=0;t<e.length;t++)n.set(0,t,e[t]);return n}static columnVector(e){let n=new I(e.length,1);for(let t=0;t<e.length;t++)n.set(t,0,e[t]);return n}static zeros(e,n){return new I(e,n)}static ones(e,n){return new I(e,n).fill(1)}static rand(e,n,t={}){if(typeof t!="object")throw new TypeError("options must be an object");const{random:s=Math.random}=t;let r=new I(e,n);for(let i=0;i<e;i++)for(let h=0;h<n;h++)r.set(i,h,s());return r}static randInt(e,n,t={}){if(typeof t!="object")throw new TypeError("options must be an object");const{min:s=0,max:r=1e3,random:i=Math.random}=t;if(!Number.isInteger(s))throw new TypeError("min must be an integer");if(!Number.isInteger(r))throw new TypeError("max must be an integer");if(s>=r)throw new RangeError("min must be smaller than max");let h=r-s,l=new I(e,n);for(let u=0;u<e;u++)for(let f=0;f<n;f++){let g=s+Math.round(i()*h);l.set(u,f,g)}return l}static eye(e,n,t){n===void 0&&(n=e),t===void 0&&(t=1);let s=Math.min(e,n),r=this.zeros(e,n);for(let i=0;i<s;i++)r.set(i,i,t);return r}static diag(e,n,t){let s=e.length;n===void 0&&(n=s),t===void 0&&(t=n);let r=Math.min(s,n,t),i=this.zeros(n,t);for(let h=0;h<r;h++)i.set(h,h,e[h]);return i}static min(e,n){e=this.checkMatrix(e),n=this.checkMatrix(n);let t=e.rows,s=e.columns,r=new I(t,s);for(let i=0;i<t;i++)for(let h=0;h<s;h++)r.set(i,h,Math.min(e.get(i,h),n.get(i,h)));return r}static max(e,n){e=this.checkMatrix(e),n=this.checkMatrix(n);let t=e.rows,s=e.columns,r=new this(t,s);for(let i=0;i<t;i++)for(let h=0;h<s;h++)r.set(i,h,Math.max(e.get(i,h),n.get(i,h)));return r}static checkMatrix(e){return _.isMatrix(e)?e:new I(e)}static isMatrix(e){return e!=null&&e.klass==="Matrix"}get size(){return this.rows*this.columns}apply(e){if(typeof e!="function")throw new TypeError("callback must be a function");for(let n=0;n<this.rows;n++)for(let t=0;t<this.columns;t++)e.call(this,n,t);return this}to1DArray(){let e=[];for(let n=0;n<this.rows;n++)for(let t=0;t<this.columns;t++)e.push(this.get(n,t));return e}to2DArray(){let e=[];for(let n=0;n<this.rows;n++){e.push([]);for(let t=0;t<this.columns;t++)e[n].push(this.get(n,t))}return e}toJSON(){return this.to2DArray()}isRowVector(){return this.rows===1}isColumnVector(){return this.columns===1}isVector(){return this.rows===1||this.columns===1}isSquare(){return this.rows===this.columns}isEmpty(){return this.rows===0||this.columns===0}isSymmetric(){if(this.isSquare()){for(let e=0;e<this.rows;e++)for(let n=0;n<=e;n++)if(this.get(e,n)!==this.get(n,e))return!1;return!0}return!1}isEchelonForm(){let e=0,n=0,t=-1,s=!0,r=!1;for(;e<this.rows&&s;){for(n=0,r=!1;n<this.columns&&r===!1;)this.get(e,n)===0?n++:this.get(e,n)===1&&n>t?(r=!0,t=n):(s=!1,r=!0);e++}return s}isReducedEchelonForm(){let e=0,n=0,t=-1,s=!0,r=!1;for(;e<this.rows&&s;){for(n=0,r=!1;n<this.columns&&r===!1;)this.get(e,n)===0?n++:this.get(e,n)===1&&n>t?(r=!0,t=n):(s=!1,r=!0);for(let i=n+1;i<this.rows;i++)this.get(e,i)!==0&&(s=!1);e++}return s}echelonForm(){let e=this.clone(),n=0,t=0;for(;n<e.rows&&t<e.columns;){let s=n;for(let r=n;r<e.rows;r++)e.get(r,t)>e.get(s,t)&&(s=r);if(e.get(s,t)===0)t++;else{e.swapRows(n,s);let r=e.get(n,t);for(let i=t;i<e.columns;i++)e.set(n,i,e.get(n,i)/r);for(let i=n+1;i<e.rows;i++){let h=e.get(i,t)/e.get(n,t);e.set(i,t,0);for(let l=t+1;l<e.columns;l++)e.set(i,l,e.get(i,l)-e.get(n,l)*h)}n++,t++}}return e}reducedEchelonForm(){let e=this.echelonForm(),n=e.columns,t=e.rows,s=t-1;for(;s>=0;)if(e.maxRow(s)===0)s--;else{let r=0,i=!1;for(;r<t&&i===!1;)e.get(s,r)===1?i=!0:r++;for(let h=0;h<s;h++){let l=e.get(h,r);for(let u=r;u<n;u++){let f=e.get(h,u)-l*e.get(s,u);e.set(h,u,f)}}s--}return e}set(){throw new Error("set method is unimplemented")}get(){throw new Error("get method is unimplemented")}repeat(e={}){if(typeof e!="object")throw new TypeError("options must be an object");const{rows:n=1,columns:t=1}=e;if(!Number.isInteger(n)||n<=0)throw new TypeError("rows must be a positive integer");if(!Number.isInteger(t)||t<=0)throw new TypeError("columns must be a positive integer");let s=new I(this.rows*n,this.columns*t);for(let r=0;r<n;r++)for(let i=0;i<t;i++)s.setSubMatrix(this,this.rows*r,this.columns*i);return s}fill(e){for(let n=0;n<this.rows;n++)for(let t=0;t<this.columns;t++)this.set(n,t,e);return this}neg(){return this.mulS(-1)}getRow(e){Q(this,e);let n=[];for(let t=0;t<this.columns;t++)n.push(this.get(e,t));return n}getRowVector(e){return I.rowVector(this.getRow(e))}setRow(e,n){Q(this,e),n=A(this,n);for(let t=0;t<this.columns;t++)this.set(e,t,n[t]);return this}swapRows(e,n){Q(this,e),Q(this,n);for(let t=0;t<this.columns;t++){let s=this.get(e,t);this.set(e,t,this.get(n,t)),this.set(n,t,s)}return this}getColumn(e){W(this,e);let n=[];for(let t=0;t<this.rows;t++)n.push(this.get(t,e));return n}getColumnVector(e){return I.columnVector(this.getColumn(e))}setColumn(e,n){W(this,e),n=tt(this,n);for(let t=0;t<this.rows;t++)this.set(t,e,n[t]);return this}swapColumns(e,n){W(this,e),W(this,n);for(let t=0;t<this.rows;t++){let s=this.get(t,e);this.set(t,e,this.get(t,n)),this.set(t,n,s)}return this}addRowVector(e){e=A(this,e);for(let n=0;n<this.rows;n++)for(let t=0;t<this.columns;t++)this.set(n,t,this.get(n,t)+e[t]);return this}subRowVector(e){e=A(this,e);for(let n=0;n<this.rows;n++)for(let t=0;t<this.columns;t++)this.set(n,t,this.get(n,t)-e[t]);return this}mulRowVector(e){e=A(this,e);for(let n=0;n<this.rows;n++)for(let t=0;t<this.columns;t++)this.set(n,t,this.get(n,t)*e[t]);return this}divRowVector(e){e=A(this,e);for(let n=0;n<this.rows;n++)for(let t=0;t<this.columns;t++)this.set(n,t,this.get(n,t)/e[t]);return this}addColumnVector(e){e=tt(this,e);for(let n=0;n<this.rows;n++)for(let t=0;t<this.columns;t++)this.set(n,t,this.get(n,t)+e[n]);return this}subColumnVector(e){e=tt(this,e);for(let n=0;n<this.rows;n++)for(let t=0;t<this.columns;t++)this.set(n,t,this.get(n,t)-e[n]);return this}mulColumnVector(e){e=tt(this,e);for(let n=0;n<this.rows;n++)for(let t=0;t<this.columns;t++)this.set(n,t,this.get(n,t)*e[n]);return this}divColumnVector(e){e=tt(this,e);for(let n=0;n<this.rows;n++)for(let t=0;t<this.columns;t++)this.set(n,t,this.get(n,t)/e[n]);return this}mulRow(e,n){Q(this,e);for(let t=0;t<this.columns;t++)this.set(e,t,this.get(e,t)*n);return this}mulColumn(e,n){W(this,e);for(let t=0;t<this.rows;t++)this.set(t,e,this.get(t,e)*n);return this}max(){if(this.isEmpty())return NaN;let e=this.get(0,0);for(let n=0;n<this.rows;n++)for(let t=0;t<this.columns;t++)this.get(n,t)>e&&(e=this.get(n,t));return e}maxIndex(){et(this);let e=this.get(0,0),n=[0,0];for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.get(t,s)>e&&(e=this.get(t,s),n[0]=t,n[1]=s);return n}min(){if(this.isEmpty())return NaN;let e=this.get(0,0);for(let n=0;n<this.rows;n++)for(let t=0;t<this.columns;t++)this.get(n,t)<e&&(e=this.get(n,t));return e}minIndex(){et(this);let e=this.get(0,0),n=[0,0];for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.get(t,s)<e&&(e=this.get(t,s),n[0]=t,n[1]=s);return n}maxRow(e){if(Q(this,e),this.isEmpty())return NaN;let n=this.get(e,0);for(let t=1;t<this.columns;t++)this.get(e,t)>n&&(n=this.get(e,t));return n}maxRowIndex(e){Q(this,e),et(this);let n=this.get(e,0),t=[e,0];for(let s=1;s<this.columns;s++)this.get(e,s)>n&&(n=this.get(e,s),t[1]=s);return t}minRow(e){if(Q(this,e),this.isEmpty())return NaN;let n=this.get(e,0);for(let t=1;t<this.columns;t++)this.get(e,t)<n&&(n=this.get(e,t));return n}minRowIndex(e){Q(this,e),et(this);let n=this.get(e,0),t=[e,0];for(let s=1;s<this.columns;s++)this.get(e,s)<n&&(n=this.get(e,s),t[1]=s);return t}maxColumn(e){if(W(this,e),this.isEmpty())return NaN;let n=this.get(0,e);for(let t=1;t<this.rows;t++)this.get(t,e)>n&&(n=this.get(t,e));return n}maxColumnIndex(e){W(this,e),et(this);let n=this.get(0,e),t=[0,e];for(let s=1;s<this.rows;s++)this.get(s,e)>n&&(n=this.get(s,e),t[0]=s);return t}minColumn(e){if(W(this,e),this.isEmpty())return NaN;let n=this.get(0,e);for(let t=1;t<this.rows;t++)this.get(t,e)<n&&(n=this.get(t,e));return n}minColumnIndex(e){W(this,e),et(this);let n=this.get(0,e),t=[0,e];for(let s=1;s<this.rows;s++)this.get(s,e)<n&&(n=this.get(s,e),t[0]=s);return t}diag(){let e=Math.min(this.rows,this.columns),n=[];for(let t=0;t<e;t++)n.push(this.get(t,t));return n}norm(e="frobenius"){let n=0;if(e==="max")return this.max();if(e==="frobenius"){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)n=n+this.get(t,s)*this.get(t,s);return Math.sqrt(n)}else throw new RangeError(`unknown norm type: ${e}`)}cumulativeSum(){let e=0;for(let n=0;n<this.rows;n++)for(let t=0;t<this.columns;t++)e+=this.get(n,t),this.set(n,t,e);return this}dot(e){_.isMatrix(e)&&(e=e.to1DArray());let n=this.to1DArray();if(n.length!==e.length)throw new RangeError("vectors do not have the same size");let t=0;for(let s=0;s<n.length;s++)t+=n[s]*e[s];return t}mmul(e){e=I.checkMatrix(e);let n=this.rows,t=this.columns,s=e.columns,r=new I(n,s),i=new Float64Array(t);for(let h=0;h<s;h++){for(let l=0;l<t;l++)i[l]=e.get(l,h);for(let l=0;l<n;l++){let u=0;for(let f=0;f<t;f++)u+=this.get(l,f)*i[f];r.set(l,h,u)}}return r}strassen2x2(e){e=I.checkMatrix(e);let n=new I(2,2);const t=this.get(0,0),s=e.get(0,0),r=this.get(0,1),i=e.get(0,1),h=this.get(1,0),l=e.get(1,0),u=this.get(1,1),f=e.get(1,1),g=(t+u)*(s+f),a=(h+u)*s,j=t*(i-f),p=u*(l-s),y=(t+r)*f,m=(h-t)*(s+i),M=(r-u)*(l+f),z=g+p-y+M,E=j+y,k=a+p,R=g-a+j+m;return n.set(0,0,z),n.set(0,1,E),n.set(1,0,k),n.set(1,1,R),n}strassen3x3(e){e=I.checkMatrix(e);let n=new I(3,3);const t=this.get(0,0),s=this.get(0,1),r=this.get(0,2),i=this.get(1,0),h=this.get(1,1),l=this.get(1,2),u=this.get(2,0),f=this.get(2,1),g=this.get(2,2),a=e.get(0,0),j=e.get(0,1),p=e.get(0,2),y=e.get(1,0),m=e.get(1,1),M=e.get(1,2),z=e.get(2,0),E=e.get(2,1),k=e.get(2,2),R=(t+s+r-i-h-f-g)*m,q=(t-i)*(-j+m),b=h*(-a+j+y-m-M-z+k),F=(-t+i+h)*(a-j+m),X=(i+h)*(-a+j),c=t*a,w=(-t+u+f)*(a-p+M),S=(-t+u)*(p-M),d=(u+f)*(-a+p),P=(t+s+r-h-l-u-f)*M,O=f*(-a+p+y-m-M-z+E),T=(-r+f+g)*(m+z-E),D=(r-g)*(m-E),Y=r*z,G=(f+g)*(-z+E),v=(-r+h+l)*(M+z-k),V=(r-l)*(M-k),J=(h+l)*(-z+k),N=s*y,B=l*E,L=i*p,C=u*j,U=g*k,wt=c+Y+N,pt=R+F+X+c+T+Y+G,dt=c+w+d+P+Y+v+J,rt=q+b+F+c+Y+v+V,it=q+F+X+c+B,lt=Y+v+V+J+L,jt=c+w+S+O+T+D+Y,ht=T+D+Y+G+C,kt=c+w+S+d+U;return n.set(0,0,wt),n.set(0,1,pt),n.set(0,2,dt),n.set(1,0,rt),n.set(1,1,it),n.set(1,2,lt),n.set(2,0,jt),n.set(2,1,ht),n.set(2,2,kt),n}mmulStrassen(e){e=I.checkMatrix(e);let n=this.clone(),t=n.rows,s=n.columns,r=e.rows,i=e.columns;s!==r&&console.warn(`Multiplying ${t} x ${s} and ${r} x ${i} matrix: dimensions do not match.`);function h(g,a,j){let p=g.rows,y=g.columns;if(p===a&&y===j)return g;{let m=_.zeros(a,j);return m=m.setSubMatrix(g,0,0),m}}let l=Math.max(t,r),u=Math.max(s,i);n=h(n,l,u),e=h(e,l,u);function f(g,a,j,p){if(j<=512||p<=512)return g.mmul(a);j%2===1&&p%2===1?(g=h(g,j+1,p+1),a=h(a,j+1,p+1)):j%2===1?(g=h(g,j+1,p),a=h(a,j+1,p)):p%2===1&&(g=h(g,j,p+1),a=h(a,j,p+1));let y=parseInt(g.rows/2,10),m=parseInt(g.columns/2,10),M=g.subMatrix(0,y-1,0,m-1),z=a.subMatrix(0,y-1,0,m-1),E=g.subMatrix(0,y-1,m,g.columns-1),k=a.subMatrix(0,y-1,m,a.columns-1),R=g.subMatrix(y,g.rows-1,0,m-1),q=a.subMatrix(y,a.rows-1,0,m-1),b=g.subMatrix(y,g.rows-1,m,g.columns-1),F=a.subMatrix(y,a.rows-1,m,a.columns-1),X=f(_.add(M,b),_.add(z,F),y,m),c=f(_.add(R,b),z,y,m),w=f(M,_.sub(k,F),y,m),S=f(b,_.sub(q,z),y,m),d=f(_.add(M,E),F,y,m),P=f(_.sub(R,M),_.add(z,k),y,m),O=f(_.sub(E,b),_.add(q,F),y,m),T=_.add(X,S);T.sub(d),T.add(O);let D=_.add(w,d),Y=_.add(c,S),G=_.sub(X,c);G.add(w),G.add(P);let v=_.zeros(2*T.rows,2*T.columns);return v=v.setSubMatrix(T,0,0),v=v.setSubMatrix(D,T.rows,0),v=v.setSubMatrix(Y,0,T.columns),v=v.setSubMatrix(G,T.rows,T.columns),v.subMatrix(0,j-1,0,p-1)}return f(n,e,l,u)}scaleRows(e={}){if(typeof e!="object")throw new TypeError("options must be an object");const{min:n=0,max:t=1}=e;if(!Number.isFinite(n))throw new TypeError("min must be a number");if(!Number.isFinite(t))throw new TypeError("max must be a number");if(n>=t)throw new RangeError("min must be smaller than max");let s=new I(this.rows,this.columns);for(let r=0;r<this.rows;r++){const i=this.getRow(r);i.length>0&&qt(i,{min:n,max:t,output:i}),s.setRow(r,i)}return s}scaleColumns(e={}){if(typeof e!="object")throw new TypeError("options must be an object");const{min:n=0,max:t=1}=e;if(!Number.isFinite(n))throw new TypeError("min must be a number");if(!Number.isFinite(t))throw new TypeError("max must be a number");if(n>=t)throw new RangeError("min must be smaller than max");let s=new I(this.rows,this.columns);for(let r=0;r<this.columns;r++){const i=this.getColumn(r);i.length&&qt(i,{min:n,max:t,output:i}),s.setColumn(r,i)}return s}flipRows(){const e=Math.ceil(this.columns/2);for(let n=0;n<this.rows;n++)for(let t=0;t<e;t++){let s=this.get(n,t),r=this.get(n,this.columns-1-t);this.set(n,t,r),this.set(n,this.columns-1-t,s)}return this}flipColumns(){const e=Math.ceil(this.rows/2);for(let n=0;n<this.columns;n++)for(let t=0;t<e;t++){let s=this.get(t,n),r=this.get(this.rows-1-t,n);this.set(t,n,r),this.set(this.rows-1-t,n,s)}return this}kroneckerProduct(e){e=I.checkMatrix(e);let n=this.rows,t=this.columns,s=e.rows,r=e.columns,i=new I(n*s,t*r);for(let h=0;h<n;h++)for(let l=0;l<t;l++)for(let u=0;u<s;u++)for(let f=0;f<r;f++)i.set(s*h+u,r*l+f,this.get(h,l)*e.get(u,f));return i}transpose(){let e=new I(this.columns,this.rows);for(let n=0;n<this.rows;n++)for(let t=0;t<this.columns;t++)e.set(t,n,this.get(n,t));return e}sortRows(e=Tt){for(let n=0;n<this.rows;n++)this.setRow(n,this.getRow(n).sort(e));return this}sortColumns(e=Tt){for(let n=0;n<this.columns;n++)this.setColumn(n,this.getColumn(n).sort(e));return this}subMatrix(e,n,t,s){Ft(this,e,n,t,s);let r=new I(n-e+1,s-t+1);for(let i=e;i<=n;i++)for(let h=t;h<=s;h++)r.set(i-e,h-t,this.get(i,h));return r}subMatrixRow(e,n,t){if(n===void 0&&(n=0),t===void 0&&(t=this.columns-1),n>t||n<0||n>=this.columns||t<0||t>=this.columns)throw new RangeError("Argument out of range");let s=new I(e.length,t-n+1);for(let r=0;r<e.length;r++)for(let i=n;i<=t;i++){if(e[r]<0||e[r]>=this.rows)throw new RangeError(`Row index out of range: ${e[r]}`);s.set(r,i-n,this.get(e[r],i))}return s}subMatrixColumn(e,n,t){if(n===void 0&&(n=0),t===void 0&&(t=this.rows-1),n>t||n<0||n>=this.rows||t<0||t>=this.rows)throw new RangeError("Argument out of range");let s=new I(t-n+1,e.length);for(let r=0;r<e.length;r++)for(let i=n;i<=t;i++){if(e[r]<0||e[r]>=this.columns)throw new RangeError(`Column index out of range: ${e[r]}`);s.set(i-n,r,this.get(i,e[r]))}return s}setSubMatrix(e,n,t){if(e=I.checkMatrix(e),e.isEmpty())return this;let s=n+e.rows-1,r=t+e.columns-1;Ft(this,n,s,t,r);for(let i=0;i<e.rows;i++)for(let h=0;h<e.columns;h++)this.set(n+i,t+h,e.get(i,h));return this}selection(e,n){let t=re(this,e,n),s=new I(e.length,n.length);for(let r=0;r<t.row.length;r++){let i=t.row[r];for(let h=0;h<t.column.length;h++){let l=t.column[h];s.set(r,h,this.get(i,l))}}return s}trace(){let e=Math.min(this.rows,this.columns),n=0;for(let t=0;t<e;t++)n+=this.get(t,t);return n}clone(){let e=new I(this.rows,this.columns);for(let n=0;n<this.rows;n++)for(let t=0;t<this.columns;t++)e.set(n,t,this.get(n,t));return e}sum(e){switch(e){case"row":return he(this);case"column":return ue(this);case void 0:return ce(this);default:throw new Error(`invalid option: ${e}`)}}product(e){switch(e){case"row":return fe(this);case"column":return ge(this);case void 0:return ae(this);default:throw new Error(`invalid option: ${e}`)}}mean(e){const n=this.sum(e);switch(e){case"row":{for(let t=0;t<this.rows;t++)n[t]/=this.columns;return n}case"column":{for(let t=0;t<this.columns;t++)n[t]/=this.rows;return n}case void 0:return n/this.size;default:throw new Error(`invalid option: ${e}`)}}variance(e,n={}){if(typeof e=="object"&&(n=e,e=void 0),typeof n!="object")throw new TypeError("options must be an object");const{unbiased:t=!0,mean:s=this.mean(e)}=n;if(typeof t!="boolean")throw new TypeError("unbiased must be a boolean");switch(e){case"row":{if(!Array.isArray(s))throw new TypeError("mean must be an array");return me(this,t,s)}case"column":{if(!Array.isArray(s))throw new TypeError("mean must be an array");return we(this,t,s)}case void 0:{if(typeof s!="number")throw new TypeError("mean must be a number");return pe(this,t,s)}default:throw new Error(`invalid option: ${e}`)}}standardDeviation(e,n){typeof e=="object"&&(n=e,e=void 0);const t=this.variance(e,n);if(e===void 0)return Math.sqrt(t);for(let s=0;s<t.length;s++)t[s]=Math.sqrt(t[s]);return t}center(e,n={}){if(typeof e=="object"&&(n=e,e=void 0),typeof n!="object")throw new TypeError("options must be an object");const{center:t=this.mean(e)}=n;switch(e){case"row":{if(!Array.isArray(t))throw new TypeError("center must be an array");return de(this,t),this}case"column":{if(!Array.isArray(t))throw new TypeError("center must be an array");return ye(this,t),this}case void 0:{if(typeof t!="number")throw new TypeError("center must be a number");return Me(this,t),this}default:throw new Error(`invalid option: ${e}`)}}scale(e,n={}){if(typeof e=="object"&&(n=e,e=void 0),typeof n!="object")throw new TypeError("options must be an object");let t=n.scale;switch(e){case"row":{if(t===void 0)t=Ee(this);else if(!Array.isArray(t))throw new TypeError("scale must be an array");return Se(this,t),this}case"column":{if(t===void 0)t=je(this);else if(!Array.isArray(t))throw new TypeError("scale must be an array");return ke(this,t),this}case void 0:{if(t===void 0)t=be(this);else if(typeof t!="number")throw new TypeError("scale must be a number");return Ie(this,t),this}default:throw new Error(`invalid option: ${e}`)}}toString(e){return zt(this,e)}}_.prototype.klass="Matrix",typeof Symbol<"u"&&(_.prototype[Symbol.for("nodejs.util.inspect.custom")]=ee);function Tt(o,e){return o-e}_.random=_.rand,_.randomInt=_.randInt,_.diagonal=_.diag,_.prototype.diagonal=_.prototype.diag,_.identity=_.eye,_.prototype.negate=_.prototype.neg,_.prototype.tensorProduct=_.prototype.kroneckerProduct;class I extends _{constructor(e,n){if(super(),I.isMatrix(e))return e.clone();if(Number.isInteger(e)&&e>=0)if(this.data=[],Number.isInteger(n)&&n>=0)for(let t=0;t<e;t++)this.data.push(new Float64Array(n));else throw new TypeError("nColumns must be a positive integer");else if(Array.isArray(e)){const t=e;if(e=t.length,n=e?t[0].length:0,typeof n!="number")throw new TypeError("Data must be a 2D array with at least one element");this.data=[];for(let s=0;s<e;s++){if(t[s].length!==n)throw new RangeError("Inconsistent array dimensions");this.data.push(Float64Array.from(t[s]))}}else throw new TypeError("First argument must be a positive number or an array");this.rows=e,this.columns=n}set(e,n,t){return this.data[e][n]=t,this}get(e,n){return this.data[e][n]}removeRow(e){return Q(this,e),this.data.splice(e,1),this.rows-=1,this}addRow(e,n){return n===void 0&&(n=e,e=this.rows),Q(this,e,!0),n=Float64Array.from(A(this,n)),this.data.splice(e,0,n),this.rows+=1,this}removeColumn(e){W(this,e);for(let n=0;n<this.rows;n++){const t=new Float64Array(this.columns-1);for(let s=0;s<e;s++)t[s]=this.data[n][s];for(let s=e+1;s<this.columns;s++)t[s-1]=this.data[n][s];this.data[n]=t}return this.columns-=1,this}addColumn(e,n){typeof n>"u"&&(n=e,e=this.columns),W(this,e,!0),n=tt(this,n);for(let t=0;t<this.rows;t++){const s=new Float64Array(this.columns+1);let r=0;for(;r<e;r++)s[r]=this.data[t][r];for(s[r++]=n[t];r<this.columns+1;r++)s[r]=this.data[t][r-1];this.data[t]=s}return this.columns+=1,this}}oe(_,I);class nt extends _{constructor(e){super(),this.data=e,this.rows=e.length,this.columns=e[0].length}set(e,n,t){return this.data[e][n]=t,this}get(e,n){return this.data[e][n]}}class Re{constructor(e){e=nt.checkMatrix(e);let n=e.clone(),t=n.rows,s=n.columns,r=new Float64Array(t),i=1,h,l,u,f,g,a,j,p,y;for(h=0;h<t;h++)r[h]=h;for(p=new Float64Array(t),l=0;l<s;l++){for(h=0;h<t;h++)p[h]=n.get(h,l);for(h=0;h<t;h++){for(y=Math.min(h,l),g=0,u=0;u<y;u++)g+=n.get(h,u)*p[u];p[h]-=g,n.set(h,l,p[h])}for(f=l,h=l+1;h<t;h++)Math.abs(p[h])>Math.abs(p[f])&&(f=h);if(f!==l){for(u=0;u<s;u++)a=n.get(f,u),n.set(f,u,n.get(l,u)),n.set(l,u,a);j=r[f],r[f]=r[l],r[l]=j,i=-i}if(l<t&&n.get(l,l)!==0)for(h=l+1;h<t;h++)n.set(h,l,n.get(h,l)/n.get(l,l))}this.LU=n,this.pivotVector=r,this.pivotSign=i}isSingular(){let e=this.LU,n=e.columns;for(let t=0;t<n;t++)if(e.get(t,t)===0)return!0;return!1}solve(e){e=I.checkMatrix(e);let n=this.LU;if(n.rows!==e.rows)throw new Error("Invalid matrix dimensions");if(this.isSingular())throw new Error("LU matrix is singular");let s=e.columns,r=e.subMatrixRow(this.pivotVector,0,s-1),i=n.columns,h,l,u;for(u=0;u<i;u++)for(h=u+1;h<i;h++)for(l=0;l<s;l++)r.set(h,l,r.get(h,l)-r.get(u,l)*n.get(h,u));for(u=i-1;u>=0;u--){for(l=0;l<s;l++)r.set(u,l,r.get(u,l)/n.get(u,u));for(h=0;h<u;h++)for(l=0;l<s;l++)r.set(h,l,r.get(h,l)-r.get(u,l)*n.get(h,u))}return r}get determinant(){let e=this.LU;if(!e.isSquare())throw new Error("Matrix must be square");let n=this.pivotSign,t=e.columns;for(let s=0;s<t;s++)n*=e.get(s,s);return n}get lowerTriangularMatrix(){let e=this.LU,n=e.rows,t=e.columns,s=new I(n,t);for(let r=0;r<n;r++)for(let i=0;i<t;i++)r>i?s.set(r,i,e.get(r,i)):r===i?s.set(r,i,1):s.set(r,i,0);return s}get upperTriangularMatrix(){let e=this.LU,n=e.rows,t=e.columns,s=new I(n,t);for(let r=0;r<n;r++)for(let i=0;i<t;i++)r<=i?s.set(r,i,e.get(r,i)):s.set(r,i,0);return s}get pivotPermutationVector(){return Array.from(this.pivotVector)}}function Z(o,e){let n=0;return Math.abs(o)>Math.abs(e)?(n=e/o,Math.abs(o)*Math.sqrt(1+n*n)):e!==0?(n=o/e,Math.abs(e)*Math.sqrt(1+n*n)):0}class ve{constructor(e){e=nt.checkMatrix(e);let n=e.clone(),t=e.rows,s=e.columns,r=new Float64Array(s),i,h,l,u;for(l=0;l<s;l++){let f=0;for(i=l;i<t;i++)f=Z(f,n.get(i,l));if(f!==0){for(n.get(l,l)<0&&(f=-f),i=l;i<t;i++)n.set(i,l,n.get(i,l)/f);for(n.set(l,l,n.get(l,l)+1),h=l+1;h<s;h++){for(u=0,i=l;i<t;i++)u+=n.get(i,l)*n.get(i,h);for(u=-u/n.get(l,l),i=l;i<t;i++)n.set(i,h,n.get(i,h)+u*n.get(i,l))}}r[l]=-f}this.QR=n,this.Rdiag=r}solve(e){e=I.checkMatrix(e);let n=this.QR,t=n.rows;if(e.rows!==t)throw new Error("Matrix row dimensions must agree");if(!this.isFullRank())throw new Error("Matrix is rank deficient");let s=e.columns,r=e.clone(),i=n.columns,h,l,u,f;for(u=0;u<i;u++)for(l=0;l<s;l++){for(f=0,h=u;h<t;h++)f+=n.get(h,u)*r.get(h,l);for(f=-f/n.get(u,u),h=u;h<t;h++)r.set(h,l,r.get(h,l)+f*n.get(h,u))}for(u=i-1;u>=0;u--){for(l=0;l<s;l++)r.set(u,l,r.get(u,l)/this.Rdiag[u]);for(h=0;h<u;h++)for(l=0;l<s;l++)r.set(h,l,r.get(h,l)-r.get(u,l)*n.get(h,u))}return r.subMatrix(0,i-1,0,s-1)}isFullRank(){let e=this.QR.columns;for(let n=0;n<e;n++)if(this.Rdiag[n]===0)return!1;return!0}get upperTriangularMatrix(){let e=this.QR,n=e.columns,t=new I(n,n),s,r;for(s=0;s<n;s++)for(r=0;r<n;r++)s<r?t.set(s,r,e.get(s,r)):s===r?t.set(s,r,this.Rdiag[s]):t.set(s,r,0);return t}get orthogonalMatrix(){let e=this.QR,n=e.rows,t=e.columns,s=new I(n,t),r,i,h,l;for(h=t-1;h>=0;h--){for(r=0;r<n;r++)s.set(r,h,0);for(s.set(h,h,1),i=h;i<t;i++)if(e.get(h,h)!==0){for(l=0,r=h;r<n;r++)l+=e.get(r,h)*s.get(r,i);for(l=-l/e.get(h,h),r=h;r<n;r++)s.set(r,i,s.get(r,i)+l*e.get(r,h))}}return s}}class Dt{constructor(e,n={}){if(e=nt.checkMatrix(e),e.isEmpty())throw new Error("Matrix must be non-empty");let t=e.rows,s=e.columns;const{computeLeftSingularVectors:r=!0,computeRightSingularVectors:i=!0,autoTranspose:h=!1}=n;let l=Boolean(r),u=Boolean(i),f=!1,g;if(t<s)if(!h)g=e.clone(),console.warn("Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose");else{g=e.transpose(),t=g.rows,s=g.columns,f=!0;let c=l;l=u,u=c}else g=e.clone();let a=Math.min(t,s),j=Math.min(t+1,s),p=new Float64Array(j),y=new I(t,a),m=new I(s,s),M=new Float64Array(s),z=new Float64Array(t),E=new Float64Array(j);for(let c=0;c<j;c++)E[c]=c;let k=Math.min(t-1,s),R=Math.max(0,Math.min(s-2,t)),q=Math.max(k,R);for(let c=0;c<q;c++){if(c<k){p[c]=0;for(let w=c;w<t;w++)p[c]=Z(p[c],g.get(w,c));if(p[c]!==0){g.get(c,c)<0&&(p[c]=-p[c]);for(let w=c;w<t;w++)g.set(w,c,g.get(w,c)/p[c]);g.set(c,c,g.get(c,c)+1)}p[c]=-p[c]}for(let w=c+1;w<s;w++){if(c<k&&p[c]!==0){let S=0;for(let d=c;d<t;d++)S+=g.get(d,c)*g.get(d,w);S=-S/g.get(c,c);for(let d=c;d<t;d++)g.set(d,w,g.get(d,w)+S*g.get(d,c))}M[w]=g.get(c,w)}if(l&&c<k)for(let w=c;w<t;w++)y.set(w,c,g.get(w,c));if(c<R){M[c]=0;for(let w=c+1;w<s;w++)M[c]=Z(M[c],M[w]);if(M[c]!==0){M[c+1]<0&&(M[c]=0-M[c]);for(let w=c+1;w<s;w++)M[w]/=M[c];M[c+1]+=1}if(M[c]=-M[c],c+1<t&&M[c]!==0){for(let w=c+1;w<t;w++)z[w]=0;for(let w=c+1;w<t;w++)for(let S=c+1;S<s;S++)z[w]+=M[S]*g.get(w,S);for(let w=c+1;w<s;w++){let S=-M[w]/M[c+1];for(let d=c+1;d<t;d++)g.set(d,w,g.get(d,w)+S*z[d])}}if(u)for(let w=c+1;w<s;w++)m.set(w,c,M[w])}}let b=Math.min(s,t+1);if(k<s&&(p[k]=g.get(k,k)),t<b&&(p[b-1]=0),R+1<b&&(M[R]=g.get(R,b-1)),M[b-1]=0,l){for(let c=k;c<a;c++){for(let w=0;w<t;w++)y.set(w,c,0);y.set(c,c,1)}for(let c=k-1;c>=0;c--)if(p[c]!==0){for(let w=c+1;w<a;w++){let S=0;for(let d=c;d<t;d++)S+=y.get(d,c)*y.get(d,w);S=-S/y.get(c,c);for(let d=c;d<t;d++)y.set(d,w,y.get(d,w)+S*y.get(d,c))}for(let w=c;w<t;w++)y.set(w,c,-y.get(w,c));y.set(c,c,1+y.get(c,c));for(let w=0;w<c-1;w++)y.set(w,c,0)}else{for(let w=0;w<t;w++)y.set(w,c,0);y.set(c,c,1)}}if(u)for(let c=s-1;c>=0;c--){if(c<R&&M[c]!==0)for(let w=c+1;w<s;w++){let S=0;for(let d=c+1;d<s;d++)S+=m.get(d,c)*m.get(d,w);S=-S/m.get(c+1,c);for(let d=c+1;d<s;d++)m.set(d,w,m.get(d,w)+S*m.get(d,c))}for(let w=0;w<s;w++)m.set(w,c,0);m.set(c,c,1)}let F=b-1,X=Number.EPSILON;for(;b>0;){let c,w;for(c=b-2;c>=-1&&c!==-1;c--){const S=Number.MIN_VALUE+X*Math.abs(p[c]+Math.abs(p[c+1]));if(Math.abs(M[c])<=S||Number.isNaN(M[c])){M[c]=0;break}}if(c===b-2)w=4;else{let S;for(S=b-1;S>=c&&S!==c;S--){let d=(S!==b?Math.abs(M[S]):0)+(S!==c+1?Math.abs(M[S-1]):0);if(Math.abs(p[S])<=X*d){p[S]=0;break}}S===c?w=3:S===b-1?w=1:(w=2,c=S)}switch(c++,w){case 1:{let S=M[b-2];M[b-2]=0;for(let d=b-2;d>=c;d--){let P=Z(p[d],S),O=p[d]/P,T=S/P;if(p[d]=P,d!==c&&(S=-T*M[d-1],M[d-1]=O*M[d-1]),u)for(let D=0;D<s;D++)P=O*m.get(D,d)+T*m.get(D,b-1),m.set(D,b-1,-T*m.get(D,d)+O*m.get(D,b-1)),m.set(D,d,P)}break}case 2:{let S=M[c-1];M[c-1]=0;for(let d=c;d<b;d++){let P=Z(p[d],S),O=p[d]/P,T=S/P;if(p[d]=P,S=-T*M[d],M[d]=O*M[d],l)for(let D=0;D<t;D++)P=O*y.get(D,d)+T*y.get(D,c-1),y.set(D,c-1,-T*y.get(D,d)+O*y.get(D,c-1)),y.set(D,d,P)}break}case 3:{const S=Math.max(Math.abs(p[b-1]),Math.abs(p[b-2]),Math.abs(M[b-2]),Math.abs(p[c]),Math.abs(M[c])),d=p[b-1]/S,P=p[b-2]/S,O=M[b-2]/S,T=p[c]/S,D=M[c]/S,Y=((P+d)*(P-d)+O*O)/2,G=d*O*(d*O);let v=0;(Y!==0||G!==0)&&(Y<0?v=0-Math.sqrt(Y*Y+G):v=Math.sqrt(Y*Y+G),v=G/(Y+v));let V=(T+d)*(T-d)+v,J=T*D;for(let N=c;N<b-1;N++){let B=Z(V,J);B===0&&(B=Number.MIN_VALUE);let L=V/B,C=J/B;if(N!==c&&(M[N-1]=B),V=L*p[N]+C*M[N],M[N]=L*M[N]-C*p[N],J=C*p[N+1],p[N+1]=L*p[N+1],u)for(let U=0;U<s;U++)B=L*m.get(U,N)+C*m.get(U,N+1),m.set(U,N+1,-C*m.get(U,N)+L*m.get(U,N+1)),m.set(U,N,B);if(B=Z(V,J),B===0&&(B=Number.MIN_VALUE),L=V/B,C=J/B,p[N]=B,V=L*M[N]+C*p[N+1],p[N+1]=-C*M[N]+L*p[N+1],J=C*M[N+1],M[N+1]=L*M[N+1],l&&N<t-1)for(let U=0;U<t;U++)B=L*y.get(U,N)+C*y.get(U,N+1),y.set(U,N+1,-C*y.get(U,N)+L*y.get(U,N+1)),y.set(U,N,B)}M[b-2]=V;break}case 4:{if(p[c]<=0&&(p[c]=p[c]<0?-p[c]:0,u))for(let S=0;S<=F;S++)m.set(S,c,-m.get(S,c));for(;c<F&&!(p[c]>=p[c+1]);){let S=p[c];if(p[c]=p[c+1],p[c+1]=S,u&&c<s-1)for(let d=0;d<s;d++)S=m.get(d,c+1),m.set(d,c+1,m.get(d,c)),m.set(d,c,S);if(l&&c<t-1)for(let d=0;d<t;d++)S=y.get(d,c+1),y.set(d,c+1,y.get(d,c)),y.set(d,c,S);c++}b--;break}}}if(f){let c=m;m=y,y=c}this.m=t,this.n=s,this.s=p,this.U=y,this.V=m}solve(e){let n=e,t=this.threshold,s=this.s.length,r=I.zeros(s,s);for(let a=0;a<s;a++)Math.abs(this.s[a])<=t?r.set(a,a,0):r.set(a,a,1/this.s[a]);let i=this.U,h=this.rightSingularVectors,l=h.mmul(r),u=h.rows,f=i.rows,g=I.zeros(u,f);for(let a=0;a<u;a++)for(let j=0;j<f;j++){let p=0;for(let y=0;y<s;y++)p+=l.get(a,y)*i.get(j,y);g.set(a,j,p)}return g.mmul(n)}solveForDiagonal(e){return this.solve(I.diag(e))}inverse(){let e=this.V,n=this.threshold,t=e.rows,s=e.columns,r=new I(t,this.s.length);for(let f=0;f<t;f++)for(let g=0;g<s;g++)Math.abs(this.s[g])>n&&r.set(f,g,e.get(f,g)/this.s[g]);let i=this.U,h=i.rows,l=i.columns,u=new I(t,h);for(let f=0;f<t;f++)for(let g=0;g<h;g++){let a=0;for(let j=0;j<l;j++)a+=r.get(f,j)*i.get(g,j);u.set(f,g,a)}return u}get condition(){return this.s[0]/this.s[Math.min(this.m,this.n)-1]}get norm2(){return this.s[0]}get rank(){let e=Math.max(this.m,this.n)*this.s[0]*Number.EPSILON,n=0,t=this.s;for(let s=0,r=t.length;s<r;s++)t[s]>e&&n++;return n}get diagonal(){return Array.from(this.s)}get threshold(){return Number.EPSILON/2*Math.max(this.m,this.n)*this.s[0]}get leftSingularVectors(){return this.U}get rightSingularVectors(){return this.V}get diagonalMatrix(){return I.diag(this.s)}}function Mt(o,e=!1){return o=nt.checkMatrix(o),e?new Dt(o).inverse():Ne(o,I.eye(o.rows))}function Ne(o,e,n=!1){return o=nt.checkMatrix(o),e=nt.checkMatrix(e),n?new Dt(o).solve(e):o.isSquare()?new Re(o).solve(e):new ve(o).solve(e)}const qe=1234,_e=()=>({seed:qe,arrayShuffle(e){const{arr:n,sampleSize:t}=e;for(let s=0;s<t;s++){this.seed=(214013*this.seed+2531011)%-2147483648;let r=this.seed>>16&32767;r=r%n.length;let i=n[s];n[s]=n[r],n[r]=i}},nextInt(e){this.seed=(214013*this.seed+2531011)%-2147483648;let n=this.seed>>16&32767;return n=n%e,n}}),K=(o,e,n)=>(e[0]-o[0])*(n[1]-o[1])-(e[1]-o[1])*(n[0]-o[0]),ze=(o,e,n,t,s,r,i,h)=>!(K(o,e,n)>0!=K(s,r,i)>0||K(e,n,t)>0!=K(r,i,h)>0||K(n,t,o)>0!=K(i,h,s)>0||K(t,o,e)>0!=K(h,s,r)>0),Fe=(o,e,n,t,s,r)=>K(o,e,n)>0==K(t,s,r)>0,Te=o=>{const e=o[4]*o[8]-o[5]*o[7],n=o[3]*o[8]-o[5]*o[6],t=o[3]*o[7]-o[4]*o[6];return o[0]*e-o[1]*n+o[2]*t},Pt=(o,e)=>{const n=Te(o);if(Math.abs(n)<=e)return null;const t=1/n;return[(o[4]*o[8]-o[5]*o[7])*t,(o[2]*o[7]-o[1]*o[8])*t,(o[1]*o[5]-o[2]*o[4])*t,(o[5]*o[6]-o[3]*o[8])*t,(o[0]*o[8]-o[2]*o[6])*t,(o[2]*o[3]-o[0]*o[5])*t,(o[3]*o[7]-o[4]*o[6])*t,(o[1]*o[6]-o[0]*o[7])*t,(o[0]*o[4]-o[1]*o[3])*t]},st=(o,e)=>{const n=e[6]*o[0]+e[7]*o[1]+e[8],t=[];return t[0]=(e[0]*o[0]+e[1]*o[1]+e[2])/n,t[1]=(e[3]*o[0]+e[4]*o[1]+e[5])/n,t},De=(o,e,n,t)=>{const s=ot(e,o),r=ot(n,o),i=ot(t,o),h=ot(e,n),l=ot(t,n),u=mt(s,r),f=mt(r,i),g=mt(s,i),a=mt(h,l);return Math.min(Math.min(Math.min(u,f),g),a)},Pe=(o,e,n,t)=>{const s=K(o,e,n)<=0;return!(K(e,n,t)<=0!==s||K(n,t,o)<=0!==s||K(t,o,e)<=0!==s)},ot=(o,e)=>[o[0]-e[0],o[1]-e[1]],mt=(o,e)=>{const n=o[0]*e[1]-o[1]*e[0];return Math.abs(n)*.5},Xt=(o,e)=>{const{normPoints:n,param:t}=Bt(o),{normPoints:s,param:r}=Bt(e),i=s.length,h=[],l=[];for(let u=0;u<i;u++){const f=[n[u][0],n[u][1],1,0,0,0,-(n[u][0]*s[u][0]),-(n[u][1]*s[u][0])],g=[0,0,0,n[u][0],n[u][1],1,-(n[u][0]*s[u][1]),-(n[u][1]*s[u][1])];h.push(f),h.push(g),l.push([s[u][0]]),l.push([s[u][1]])}try{const u=new I(h),f=new I(l),g=u.transpose(),a=g.mmul(u),j=g.mmul(f),y=Mt(a).mmul(j).to1DArray();return Xe(y,t,r)}catch{return null}},Bt=o=>{let e=0,n=0;for(let l=0;l<o.length;l++)e+=o[l][0],n+=o[l][1];let t=e/o.length,s=n/o.length,r=0;for(let l=0;l<o.length;l++){const u=o[l][0]-t,f=o[l][1]-s;r+=Math.sqrt(u*u+f*f)}let i=Math.sqrt(2)*o.length/r;const h=[];for(let l=0;l<o.length;l++)h.push([(o[l][0]-t)*i,(o[l][1]-s)*i]);return{normPoints:h,param:{meanX:t,meanY:s,s:i}}},Xe=(o,e,n)=>{const t=n.s*n.meanX,s=n.s*n.meanY,r=[o[0]+t*o[6],o[1]+t*o[7],(o[0]+t*o[6])*-e.meanX+(o[1]+t*o[7])*-e.meanY+(o[2]+t)/e.s,o[3]+s*o[6],o[4]+s*o[7],(o[3]+s*o[6])*-e.meanX+(o[4]+s*o[7])*-e.meanY+(o[5]+s)/e.s,n.s*o[6],n.s*o[7],n.s*o[6]*-e.meanX+n.s*o[7]*-e.meanY+n.s/e.s];for(let i=0;i<9;i++)r[i]=r[i]/r[8];return r},Be=.01,Ue=10,Oe=20,Ve=10,Ut=o=>{const{srcPoints:e,dstPoints:n,keyframe:t,quickMode:s}=o,r=[[0,0],[t.width,0],[t.width,t.height],[0,t.height]],i=4;if(e.length<i)return null;const h=Be,l=1/(h*h),u=Math.min(Ue,e.length),f=_e(),g=[];for(let E=0;E<e.length;E++)g[E]=E;f.arrayShuffle({arr:g,sampleSize:g.length});const a=s?Ve:Oe,j=a*2;let p=0;const y=[];for(;p<j&&y.length<a;){if(p+=1,f.arrayShuffle({arr:g,sampleSize:i}),!ze(e[g[0]],e[g[1]],e[g[2]],e[g[3]],n[g[0]],n[g[1]],n[g[2]],n[g[3]]))continue;const E=Xt([e[g[0]],e[g[1]],e[g[2]],e[g[3]]],[n[g[0]],n[g[1]],n[g[2]],n[g[3]]]);E!==null&&(!Ce({H:E,testPoints:r})||y.push(E))}if(y.length===0)return null;const m=[];for(let E=0;E<y.length;E++)m.push({H:y[E],cost:0});let M=u;for(let E=0;E<e.length&&m.length>2;E+=M){M=Math.min(u,e.length-E);let k=E+M;for(let R=0;R<m.length;R++)for(let q=E;q<k;q++){const b=Ye({H:m[R].H,srcPoint:e[q],dstPoint:n[q],oneOverScale2:l});m[R].cost+=b}m.sort((R,q)=>R.cost-q.cost),m.splice(-Math.floor((m.length+1)/2))}let z=null;for(let E=0;E<m.length;E++){const k=$e({inH:m[E].H});if(Le({H:k,testPoints:r,keyframe:t})){z=k;break}}return z},Le=({H:o,testPoints:e,keyframe:n})=>{const t=Pt(o,1e-5);if(t===null)return!1;const s=[];for(let i=0;i<e.length;i++)s.push(st(e[i],t));return!(De(s[0],s[1],s[2],s[3])<n.width*n.height*1e-4||!Pe(s[0],s[1],s[2],s[3]))},$e=({inH:o})=>{const e=1/o[8],n=[];for(let t=0;t<8;t++)n[t]=o[t]*e;return n[8]=1,n},Ye=({H:o,srcPoint:e,dstPoint:n,oneOverScale2:t})=>{const s=st(e,o),r=[s[0]-n[0],s[1]-n[1]];return Math.log(1+(r[0]*r[0]+r[1]*r[1])*t)},Ce=({H:o,testPoints:e})=>{const n=[];for(let t=0;t<e.length;t++)n[t]=st(e[t],o);for(let t=0;t<e.length;t++){const s=t,r=(t+1)%e.length,i=(t+2)%e.length;if(!Fe(e[s],e[r],e[i],n[s],n[r],n[i]))return!1}return!0},Ot=3,Vt=6,He=8,Lt=.7,Je=({keyframe:o,querypoints:e,querywidth:n,queryheight:t,debugMode:s})=>{let r={};const i=[];for(let m=0;m<e.length;m++){const M=e[m],z=M.maxima?o.maximaPoints:o.minimaPoints;if(z.length===0)continue;const E=M.maxima?o.maximaPointsCluster.rootNode:o.minimaPointsCluster.rootNode,k=[],R=new Gt([],(X,c)=>X.d-c.d);Et({node:E,keypoints:z,querypoint:M,queue:R,keypointIndexes:k,numPop:0});let q=-1,b=Number.MAX_SAFE_INTEGER,F=Number.MAX_SAFE_INTEGER;for(let X=0;X<k.length;X++){const c=z[k[X]],w=yt({v1:c.descriptors,v2:M.descriptors});w<b?(F=b,b=w,q=k[X]):w<F&&(F=w)}q!==-1&&(F===Number.MAX_SAFE_INTEGER||1*b/F<Lt)&&i.push({querypoint:M,keypoint:z[q]})}if(s&&(r.matches=i),i.length<Vt)return{debugExtra:r};const h=Nt({keywidth:o.width,keyheight:o.height,querywidth:n,queryheight:t,matches:i});s&&(r.houghMatches=h);const l=Ut({srcPoints:h.map(m=>[m.keypoint.x,m.keypoint.y]),dstPoints:h.map(m=>[m.querypoint.x,m.querypoint.y]),keyframe:o});if(l===null)return{debugExtra:r};const u=$t({H:l,matches:h,threshold:Ot});if(s&&(r.inlierMatches=u),u.length<Vt)return{debugExtra:r};const f=Pt(l,1e-5),g=10*10,a=[];for(let m=0;m<e.length;m++){const M=e[m],z=st([M.x,M.y],f);let E=-1,k=Number.MAX_SAFE_INTEGER,R=Number.MAX_SAFE_INTEGER;const q=M.maxima?o.maximaPoints:o.minimaPoints;for(let b=0;b<q.length;b++){const F=q[b];if((F.x-z[0])*(F.x-z[0])+(F.y-z[1])*(F.y-z[1])>g)continue;const c=yt({v1:F.descriptors,v2:M.descriptors});c<k?(R=k,k=c,E=b):c<R&&(R=c)}E!==-1&&(R===Number.MAX_SAFE_INTEGER||1*k/R<Lt)&&a.push({querypoint:M,keypoint:q[E]})}s&&(r.matches2=a);const j=Nt({keywidth:o.width,keyheight:o.height,querywidth:n,queryheight:t,matches:a});s&&(r.houghMatches2=j);const p=Ut({srcPoints:j.map(m=>[m.keypoint.x,m.keypoint.y]),dstPoints:j.map(m=>[m.querypoint.x,m.querypoint.y]),keyframe:o});if(p===null)return{debugExtra:r};const y=$t({H:p,matches:j,threshold:Ot});return s&&(r.inlierMatches2=y),{H:p,matches:y,debugExtra:r}},Et=({node:o,keypoints:e,querypoint:n,queue:t,keypointIndexes:s,numPop:r})=>{if(o.leaf){for(let l=0;l<o.pointIndexes.length;l++)s.push(o.pointIndexes[l]);return}const i=[];for(let l=0;l<o.children.length;l++){const f=o.children[l].centerPointIndex,g=yt({v1:e[f].descriptors,v2:n.descriptors});i.push(g)}let h=Number.MAX_SAFE_INTEGER;for(let l=0;l<o.children.length;l++)h=Math.min(h,i[l]);for(let l=0;l<o.children.length;l++)i[l]!==h&&t.push({node:o.children[l],d:i[l]});for(let l=0;l<o.children.length;l++)i[l]===h&&Et({node:o.children[l],keypoints:e,querypoint:n,queue:t,keypointIndexes:s,numPop:r});if(r<He&&t.length>0){const{node:l,d:u}=t.pop();r+=1,Et({node:l,keypoints:e,querypoint:n,queue:t,keypointIndexes:s,numPop:r})}},$t=o=>{const{H:e,matches:n,threshold:t}=o,s=t*t,r=[];for(let i=0;i<n.length;i++){const h=n[i].querypoint,l=n[i].keypoint,u=st([l.x,l.y],e);(u[0]-h.x)*(u[0]-h.x)+(u[1]-h.y)*(u[1]-h.y)<=s&&r.push(n[i])}return r};class Ke{constructor(e,n,t=!1){this.queryWidth=e,this.queryHeight=n,this.debugMode=t}matchDetection(e,n){let t={frames:[]},s=null;for(let l=0;l<e.length;l++){const{H:u,matches:f,debugExtra:g}=Je({keyframe:e[l],querypoints:n,querywidth:this.queryWidth,queryheight:this.queryHeight,debugMode:this.debugMode});t.frames.push(g),u&&(s===null||s.matches.length<f.length)&&(s={keyframeIndex:l,H:u,matches:f})}if(s===null)return{keyframeIndex:-1,debugExtra:t};const r=[],i=[],h=e[s.keyframeIndex];for(let l=0;l<s.matches.length;l++){const u=s.matches[l].querypoint,f=s.matches[l].keypoint;r.push({x:u.x,y:u.y}),i.push({x:(f.x+.5)/h.scale,y:(f.y+.5)/h.scale,z:0})}return{screenCoords:r,worldCoords:i,keyframeIndex:s.keyframeIndex,debugExtra:t}}}const Ge=({screenCoords:o,worldCoords:e,projectionTransform:n})=>{const t=Xt(e.map(m=>[m.x,m.y]),o.map(m=>[m.x,m.y])),s=new I([[t[0],t[1],t[2]],[t[3],t[4],t[5]],[t[6],t[7],t[8]]]),r=new I(n),l=Mt(r).mmul(s).to1DArray(),u=Math.sqrt(l[0]*l[0]+l[3]*l[3]+l[6]*l[6]),f=Math.sqrt(l[1]*l[1]+l[4]*l[4]+l[7]*l[7]),g=(u+f)/2,a=[];a[0]=l[0]/u,a[3]=l[3]/u,a[6]=l[6]/u,a[1]=l[1]/f,a[4]=l[4]/f,a[7]=l[7]/f,a[2]=a[3]*a[7]-a[6]*a[4],a[5]=a[6]*a[1]-a[0]*a[7],a[8]=a[0]*a[4]-a[1]*a[3];const j=Math.sqrt(a[2]*a[2]+a[5]*a[5]+a[8]*a[8]);a[2]/=j,a[5]/=j,a[8]/=j;const p=[];return p[0]=l[2]/g,p[1]=l[5]/g,p[2]=l[8]/g,[[a[0],a[1],a[2],p[0]],[a[3],a[4],a[5],p[1]],[a[6],a[7],a[8],p[2]]]},Qe=(o,e)=>[[o[0][0]*e[0][0]+o[0][2]*e[2][0],o[0][0]*e[0][1]+o[0][2]*e[2][1],o[0][0]*e[0][2]+o[0][2]*e[2][2],o[0][0]*e[0][3]+o[0][2]*e[2][3]],[o[1][1]*e[1][0]+o[1][2]*e[2][0],o[1][1]*e[1][1]+o[1][2]*e[2][1],o[1][1]*e[1][2]+o[1][2]*e[2][2],o[1][1]*e[1][3]+o[1][2]*e[2][3]],[e[2][0],e[2][1],e[2][2],e[2][3]]],Yt=(o,e,n,t)=>{const s=o[0][0]*e+o[0][1]*n+o[0][3],r=o[1][0]*e+o[1][1]*n+o[1][3],i=o[2][0]*e+o[2][1]*n+o[2][3];return{x:s,y:r,z:i}},We=(o,e,n,t)=>{const{x:s,y:r,z:i}=Yt(o,e,n);return{x:s/i,y:r/i}},Ze=5,xe=4,Ct=10,Ae=.1,tn=.99;let H=[[],[],[]],x=[[],[]],$=[[],[],[]];const en=({initialModelViewTransform:o,projectionTransform:e,worldCoords:n,screenCoords:t})=>{let s=0,r=0;for(let g=0;g<n.length;g++)s+=n[g].x,r+=n[g].y;s/=n.length,r/=n.length;const i=[];for(let g=0;g<n.length;g++)i.push({x:n[g].x-s,y:n[g].y-r,z:n[g].z});const h=[[],[],[]];for(let g=0;g<3;g++)for(let a=0;a<3;a++)h[g][a]=o[g][a];h[0][3]=o[0][0]*s+o[0][1]*r+o[0][3],h[1][3]=o[1][0]*s+o[1][1]*r+o[1][3],h[2][3]=o[2][0]*s+o[2][1]*r+o[2][3];const l=[1,.8,.6,.4,0];let u=h,f=null;for(let g=0;g<l.length;g++){const a=nn({initialModelViewTransform:u,projectionTransform:e,worldCoords:i,screenCoords:t,inlierProb:l[g]});if(u=a.modelViewTransform,a.err<Ze){f=u;break}}return f===null?null:(f[0][3]=f[0][3]-f[0][0]*s-f[0][1]*r,f[1][3]=f[1][3]-f[1][0]*s-f[1][1]*r,f[2][3]=f[2][3]-f[2][0]*s-f[2][1]*r,f)},nn=({initialModelViewTransform:o,projectionTransform:e,worldCoords:n,screenCoords:t,inlierProb:s})=>{const r=s<1;let i=o,h=0,l=0,u=new Array(n.length),f=new Array(n.length),g=new Array(n.length),a=new Array(n.length);for(let j=0;j<=Ct;j++){const p=Qe(e,i);for(let E=0;E<n.length;E++){const k=We(p,n[E].x,n[E].y,n[E].z),R=t[E].x-k.x,q=t[E].y-k.y;g[E]=R,a[E]=q,u[E]=R*R+q*q}let y;if(l=0,r){const E=Math.max(3,Math.floor(n.length*s)-1);for(let k=0;k<n.length;k++)f[k]=u[k];f.sort((k,R)=>k-R),y=Math.max(f[E]*xe,16);for(let k=0;k<n.length;k++)f[k]>y?l+=y/6:l+=y/6*(1-(1-f[k]/y)*(1-f[k]/y)*(1-f[k]/y))}else for(let E=0;E<n.length;E++)l+=u[E];if(l/=n.length,l<Ae||j>0&&l/h>tn||j===Ct)break;h=l;const m=[],M=[];for(let E=0;E<n.length;E++){if(r&&u[E]>y)continue;const k=rn({modelViewProjectionTransform:p,modelViewTransform:i,projectionTransform:e,worldCoord:n[E]});if(r){const R=(1-u[E]/y)*(1-u[E]/y);for(let q=0;q<2;q++)for(let b=0;b<6;b++)k[q][b]*=R;m.push([g[E]*R]),m.push([a[E]*R])}else m.push([g[E]]),m.push([a[E]]);for(let R=0;R<k.length;R++)M.push(k[R])}const z=on({dU:m,J_U_S:M});if(z===null)break;i=sn({modelViewTransform:i,dS:z})}return{modelViewTransform:i,err:l}},sn=({modelViewTransform:o,dS:e})=>{let n=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],t,s,r;n<1e-6?(t=1,s=0,r=0,n=0):(n=Math.sqrt(n),t=e[0]/n,s=e[1]/n,r=e[2]/n);const i=Math.cos(n),h=Math.sin(n),l=1-i;H[0][0]=t*t*l+i,H[0][1]=t*s*l-r*h,H[0][2]=t*r*l+s*h,H[0][3]=e[3],H[1][0]=s*t*l+r*h,H[1][1]=s*s*l+i,H[1][2]=s*r*l-t*h,H[1][3]=e[4],H[2][0]=r*t*l-s*h,H[2][1]=r*s*l+t*h,H[2][2]=r*r*l+i,H[2][3]=e[5];const u=[[],[],[]];for(let f=0;f<3;f++){for(let g=0;g<4;g++)u[f][g]=o[f][0]*H[0][g]+o[f][1]*H[1][g]+o[f][2]*H[2][g];u[f][3]+=o[f][3]}return u},on=({dU:o,J_U_S:e})=>{const n=new I(e),t=new I(o),s=n.transpose(),r=s.mmul(n),i=s.mmul(t);let h;try{h=Mt(r)}catch{return null}return h.mmul(i).to1DArray()},rn=({modelViewProjectionTransform:o,modelViewTransform:e,projectionTransform:n,worldCoord:t})=>{const s=e,{x:r,y:i,z:h}=t,l=Yt(o,r,i),u=l.z*l.z;x[0][0]=n[0][0]*l.z/u,x[0][1]=n[0][1]*l.z/u,x[0][2]=(n[0][2]*l.z-n[2][2]*l.x)/u,x[1][0]=n[1][0]*l.z/u,x[1][1]=n[1][1]*l.z/u,x[1][2]=(n[1][2]*l.z-n[2][2]*l.y)/u,$[0][0]=s[0][2]*i,$[0][1]=-s[0][2]*r,$[0][2]=s[0][1]*r-s[0][0]*i,$[0][3]=s[0][0],$[0][4]=s[0][1],$[0][5]=s[0][2],$[1][0]=s[1][2]*i,$[1][1]=-s[1][2]*r,$[1][2]=s[1][1]*r-s[1][0]*i,$[1][3]=s[1][0],$[1][4]=s[1][1],$[1][5]=s[1][2],$[2][0]=s[2][2]*i,$[2][1]=-s[2][2]*r,$[2][2]=s[2][1]*r-s[2][0]*i,$[2][3]=s[2][0],$[2][4]=s[2][1],$[2][5]=s[2][2];const f=[[],[]];for(let g=0;g<2;g++)for(let a=0;a<6;a++){f[g][a]=0;for(let j=0;j<3;j++)f[g][a]+=x[g][j]*$[j][a]}return f};class ln{constructor(e){this.projectionTransform=e}estimate({screenCoords:e,worldCoords:n}){return Ge({screenCoords:e,worldCoords:n,projectionTransform:this.projectionTransform})}refineEstimate({initialModelViewTransform:e,worldCoords:n,screenCoords:t}){return en({initialModelViewTransform:e,worldCoords:n,screenCoords:t,projectionTransform:this.projectionTransform})}}let Ht=null,Jt=!1,Kt=null,St=null;onmessage=o=>{const{data:e}=o;if(e.type==="setup")e.projectionTransform,Ht=e.matchingDataList,Jt=e.debugMode,Kt=new Ke(e.inputWidth,e.inputHeight,Jt),St=new ln(e.projectionTransform);else if(e.type==="match"){const n=e.targetIndexes;let t=-1,s=null,r=null;for(let i=0;i<n.length;i++){const h=n[i],{keyframeIndex:l,screenCoords:u,worldCoords:f,debugExtra:g}=Kt.matchDetection(Ht[h],e.featurePoints);if(r=g,l!==-1){const a=St.estimate({screenCoords:u,worldCoords:f});a&&(t=h,s=a);break}}postMessage({type:"matchDone",targetIndex:t,modelViewTransform:s,debugExtra:r})}else if(e.type==="trackUpdate"){const{modelViewTransform:n,worldCoords:t,screenCoords:s}=e,r=St.refineEstimate({initialModelViewTransform:n,worldCoords:t,screenCoords:s});postMessage({type:"trackUpdateDone",modelViewTransform:r})}}})();
